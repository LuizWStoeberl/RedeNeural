import os
import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from models import db, Treinamento

MODELO_SALVO_PATH = 'modelos_salvos/modelo_cnn.h5'
os.makedirs('modelos_salvos', exist_ok=True)

def get_ultimo_treinamento():
    return Treinamento.query.order_by(Treinamento.id.desc()).first()

def treinar_rede_neural_cnn():
    config = get_ultimo_treinamento()
    if not config:
        raise Exception("Nenhuma configuração de treinamento encontrada no banco de dados")

    # Parâmetros do usuário
    epocas = config.epocas
    neuronios = config.neuronios
    camadas_convolucionais = config.enlaces  # Usando enlaces como camadas convolucionais
    tamanho_imagem = (150, 150)
    teste_size = getattr(config, 'teste_size', 0.2)

    # Configuração dos geradores de imagens
    train_datagen = ImageDataGenerator(rescale=1./255)
    test_datagen = ImageDataGenerator(rescale=1./255)

    # Ajuste os caminhos para as pastas de treinamento e teste
    train_generator = train_datagen.flow_from_directory(
        'arquivosRede2/teste',  # Ajuste para o diretório correto
        target_size=tamanho_imagem,
        batch_size=32,
        class_mode='binary'
    )

    validation_generator = test_datagen.flow_from_directory(
        'arquivosRede2/teste',  # Ajuste para o diretório correto
        target_size=tamanho_imagem,
        batch_size=32,
        class_mode='binary'
    )

    # Arquitetura da Rede Neural Convolucional
    modelo_cnn = tf.keras.models.Sequential()
    modelo_cnn.add(tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)))
    modelo_cnn.add(tf.keras.layers.MaxPooling2D((2, 2)))
    
    for _ in range(camadas_convolucionais - 1):
        modelo_cnn.add(tf.keras.layers.Conv2D(32, (3, 3), activation='relu'))
        modelo_cnn.add(tf.keras.layers.MaxPooling2D((2, 2)))

    modelo_cnn.add(tf.keras.layers.Flatten())
    modelo_cnn.add(tf.keras.layers.Dense(128, activation='relu'))
    modelo_cnn.add(tf.keras.layers.Dense(1, activation='sigmoid'))

    # Compilação e Treinamento
    modelo_cnn.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    historico = modelo_cnn.fit(
        train_generator,
        epochs=epocas,
        validation_data=validation_generator
    )

    # Avaliação com o validation_generator
    validation_generator.reset()  # Reseta o gerador para evitar problemas
    previsoes = modelo_cnn.predict(validation_generator)
    previsoes = (previsoes > 0.5).astype(int)
    y_true = validation_generator.classes
    acc = accuracy_score(y_true, previsoes)
    cm = confusion_matrix(y_true, previsoes)

    # Salva o modelo treinado
    modelo_cnn.save(MODELO_SALVO_PATH)

    return acc, cm

def classificar_nova_imagem_cnn(caminho_imagem):
    if not os.path.exists(MODELO_SALVO_PATH):
        raise Exception("Modelo treinado não encontrado. Treine a rede neural primeiro!")
    modelo_cnn = tf.keras.models.load_model(MODELO_SALVO_PATH)
    img = tf.keras.preprocessing.image.load_img(caminho_imagem, target_size=(150, 150))
    img_array = tf.keras.preprocessing.image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)
    previsao = modelo_cnn.predict(img_array)
    return previsao